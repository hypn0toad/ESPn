/*********************************************************************
  M. A. I. D. O. (L)
  mechanically assisted inventive device offering love
  
  Written by Nate McBean for Christine Chan!
  This is the IMP code
  
  Based off of "Transmit data between UART and Input/OutputPorts on 
  the impee" by: Jim Lindblom SparkFun Electronics license: BeerWare
  
  PIN1- nc
  PIN2- nc
  PIN5- Imp Transmit (connect to Rx of arduino)
  PIN7- Imp Receive  (connect to Tx of arduino)
  PIN8- nc  
  PIN9- LED Tx (on when receive from internet and tx to arduino)
  
  
  Revision Log
  Date       |Author     |Description
  -----------|-----------|-------------------------------------------
  09/26/2012  J. Lindblom Public code release from sparkfun
  04/03/2013  N. McBean   Added watchdog function to prevent imp from
                          sleeping (was sleeping after 15m)
  04/07/2013  N. McBean   Changed to use callback instead of polling
******************************************************************/

local rxLEDToggle = 1;  // These variables keep track of rx/tx LED toggling status
local txLEDToggle = 1;

// impeeIn will override the InputPort class. 
// Whenever data is received to the impee, we'll jump into the set(c) function defined within
class impeeIn extends InputPort
{
    name = "UART Out";
    type = "string";
    
    // This function takes whatever character was sent to the impee
    // and sends it out over the UART5/7. We'll also toggle the txLed
    function set(c)
    {
        hardware.uart57.write(c);
        //server.log(format("Internet to Ard %s", c)); // send the character out to the server log. Optional, great for debugging
        server.show(c);
        toggleRxLED();
    }
}

local impeeInput = impeeIn();  // assign impeeIn class to the impeeInput
local impeeOutput = OutputPort("UART In", "string");  // set impeeOutput as a string

function initUart()
{
    hardware.configure(UART_57);    // Using UART on pins 5 and 7
    hardware.uart57.configure(19200, 8, PARITY_NONE, 1, NO_CTSRTS,readserial); // 19200 baud worked well, no parity, 1 stop bit, 8 data bits
}

function initLEDs()
{
    // LEDs are on pins 8 and 9 on the imp Shield
    // They're both active low, so writing the pin a 1 will turn the LED off
    hardware.pin8.configure(DIGITAL_OUT_OD_PULLUP);
    hardware.pin9.configure(DIGITAL_OUT_OD_PULLUP);
    hardware.pin8.write(1);
    hardware.pin9.write(1);
    
    // LED for wifi status
    hardware.pin2.configure(DIGITAL_OUT_OD_PULLUP);
    hardware.pin2.write(1);
}

// This function turns an LED on/off quickly on pin 9.
// It first turns the LED on, then calls itself again in 50ms to turn the LED off
function toggleTxLED()
{
    txLEDToggle = txLEDToggle?0:1;    // toggle the txLEDtoggle variable
    if (!txLEDToggle)
    {
        imp.wakeup(0.05, toggleTxLED.bindenv(this)); // if we're turning the LED on, set a timer to call this function again (to turn the LED off)
    }
    hardware.pin8.write(txLEDToggle);  // TX LED is on pin 8 (active-low)
}

// This function turns an LED on/off quickly on pin 8.
// It first turns the LED on, then calls itself again in 50ms to turn the LED off
function toggleRxLED()
{
    rxLEDToggle = rxLEDToggle?0:1;    // toggle the rxLEDtoggle variable
    if (!rxLEDToggle)
    {
        imp.wakeup(0.05, toggleRxLED.bindenv(this)); // if we're turning the LED on, set a timer to call this function again (to turn the LED off)
    }
    hardware.pin9.write(rxLEDToggle);   // RX LED is on pin 9 (active-low)
}

// If there is data in the UART57 buffer, this function will be called and we will
// this will read as much of it as it can, and send it out of the impee's outputPort.
function readserial()
{
    local byte = hardware.uart57.read();    // read the UART buffer
    while (byte != -1)  // otherwise, we keep reading until there is no data to be read.
    {
        server.log(format("Ard to Internet %c", byte)); // send the character out to the server log. Optional, great for debugging
        impeeOutput.set(byte);  // send the valid character out the impee's outputPort
        byte = hardware.uart57.read();  // read from the UART buffer again (not sure if it's a valid character yet)
        toggleTxLED();  // Toggle the TX LED
    }
    
}

function watchdog() {
  imp.wakeup(5*60, watchdog);
  server.log("watchdog");
}

// lets keep checking our wireless health. 
// check rapidly when not connected. back off when connected
function checkWifi() {
  
  // according to documentation, above -67dbm is good enough
  // http://devwiki.electricimp.com/doku.php?id=electricimpapi:imp:rssi
  if( imp.rssi() > -67) {
    // wifi is good
    hardware.pin2.write(0);
    // don't bother checking for another minute almost
    imp.wakeup(58,checkWifi);
    //server.log("Wifi good");
  } else {
    // wifi is bad
    hardware.pin2.write(1);
    // check in a few seconds
    imp.wakeup(5,checkWifi);
    //server.log("Wifi bad");
  }
    
}

// This is where our program actually starts! Previous stuff was all function and variable declaration.
// This'll configure our impee. It's name is "UartCrossAir", and it has both an input and output to be connected:
imp.configure("UART_MASTER", [impeeInput], [impeeOutput]);
initUart(); // Initialize the UART, called just once
initLEDs(); // Initialize the LEDs, called just once
watchdog();
checkWifi();
// From here, two main functions are at play:
//      1. We'll be calling pollUart every 10us. If data is sent from the UART, we'll send out out of the impee.
//      2. If data is sent into the impee, we'll jump into the set function in the InputPort.
//
// The end